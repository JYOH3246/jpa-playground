## 03.04 영속성 컨텍스트의 특징

- 영속성 컨텍스트와 식별자 값
    - 엔티티를 식별자 값(@Id)으로 구분합니다.
    - 영속 상태는 식별자 값이 반드시 있어야 합니다. (없으면 예외가 발생합니다.)
- 영속성 컨텍스트와 데이터베이스 저장
- 영속성 컨텍스트가 엔티티 관리할 때 장점
    - 1차 캐시
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지
    - 지연 로딩

### 1. 엔티티 조회(1차 캐시, 동일성 보장)

```kotlin
val A = entityManager.find(Member.class, "1") // DB를 통해 조회
val B = entityManager.find(Member.class, "1") // 1차 캐시를 통해 조회
```

- 영속성 컨텍스트는 내부에 캐시를 가지고 있는데, 이를 `1차 캐시`라고 합니다.
- 영속 상태의 엔티티가 모두 `1차 캐시`에 저장됩니다.
- Map (`key : value`) 형태로 저장되며, 실제로는 `@Id : Entity`가 들어있습니다.

> 조회 동작 원리(1차 캐시)

1. @Id 식별자를 통해 영속성 컨텍스트의 1차 캐시에 찾고자 하는 Entity가 존재하는지 확인합니다.
2. 존재한다면 해당 엔티티를 1차 캐시에서 조회합니다.
3. 엔티티를 반환합니다.

- 1차 캐시를 통해 엔티티를 조회 할 때는 DB에 접근을 하지 않아도 되기 때문에 성능상 이점이 있습니다.

> 조회 동작 원리(DB)

1. 영속성 컨텍스트의 1차 캐시에 찾고자 하는 Entity가 존재하지 않습니다.
2. 데이터 베이스를 조회하여 엔티티를 생성합니다.
3. 생성된 엔티티를 1차 캐시에 저장합니다.
4. 엔티티를 반환합니다.

> 영속 엔티티 동일성 보장

```kotlin
val A = entityManager.find(Member.class, "1") // DB를 통해 조회
val B = entityManager.find(Member.class, "1") // 1차 캐시를 통해 조회

if (A == B) println("두 엔티티는 같은 엔티티 입니다!")
```

식별자가 같은 엔티티를 조회해서 비교했을 때, 1차 캐시를 통해 조회하여 같은 인스턴스를 반환하기 때문에 동일성이 보장됩니다.

### 2. 엔티티 등록(트랜잭션을 지원하는 쓰기 지연)

```kotlin
// 트랜잭션 시작
transaction.begin()

val member = Member("1")

entityManager.persist(member)

// 트랜잭션 커밋
transaction.commit() 
```

1. 트랜잭션이 시작됩니다.
2. 엔티티를 생성하여 persist()를 통해 엔티티를 1차 캐시에 저장합니다.
3. 커밋 전까지 INSERT 쿼리를 `쓰기 지연 SQL 저장소`에 보관합니다.
4. 트랜잭션이 커밋됩니다.
5. 영속성 컨텍스트가 플러쉬 되고, 영속성 컨텍스트는 DB와의 동기화를 위해 `쓰기 지연 SQL 저장소`에 보관된 쿼리를 DB에 보냅니다.
6. 동기화한 후에 DB의 트랜잭션을 커밋합니다.

이러한 쓰기 지연을 SQL Batch 등을 통해 잘 활용하면 성능을 최적화 할 수 있습니다.

### 3. 엔티티 수정(변경 감지)

> 변경 감지(Dirty Checking)

- 영속 상태에 있는 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능입니다.

> 수정 동작 원리

1. 엔티티를 영속성 컨텍스트에 보관할 때 최초의 상태를 복사(`스냅샷`)해서 저장합니다.
2. 트랜잭션이 커밋됩니다.
3. 엔티티 매니저 플러쉬 시점에 스냅샷과 현재 엔티티를 비교하여 변경된 부분을 찾습니다.
4. 변경된 데이터가 있다면 UPDATE 쿼리를 생성하여 쓰기 지연 SQL 저장소에 보관합니다.
5. 영속성 컨텍스트가 플러쉬 되고, `쓰기 지연 SQL 저장소`에 보관된 쿼리를 DB에 보냅니다.
6. 동기화한 후에 DB의 트랜잭션을 커밋합니다.

> JPA UPDATE 기본 전략

- JPA는 모든 필드를 업데이트 하는 UPDATE 쿼리를 생성합니다.
    - DB에 보내는 데이터 전송량이 증가하지만, 수정 쿼리가 항상 같기 때문에 수정 쿼리를 미리 생성하여 쓸 수 있습니다.
    - DB는 이전에 파싱된 쿼리를 재사용할 수 있습니다.
- @DynamicUpdate 어노테이션을 사용하면 변경 사항에만 UPDATE 쿼리를 생성할 수 있습니다.

### 4. 엔티티 삭제

```kotlin
val member = entityManage.find(Member.class, "1")

entityManager.remove(mebmer)
```

- 엔티티를 삭제하기 위해선 엔티티가 영속성 컨텍스트에 의해 관리될 수 있는 상태, 즉 영속 상태로 만들어야 합니다.

> 삭제 동작 원리

1. 엔티티를 조회하여 영속 상태로 만듭니다.
2. DELETE 쿼리를 쓰기 지연 SQL 저장소에 보관합니다.
3. 트랜잭션이 커밋됩니다.
4. 영속성 컨텍스트가 플러쉬 되고, 쓰기 지연 SQL 저장소에 보관된 쿼리를 DB에 보냅니다.
5. 영속성 컨텍스트 내부에서도 엔티티가 제거됩니다.
6. 삭제된 엔티티는 가비지 컬렉팅의 대상이 되어 메모리에서 사라집니다.

